systemd:
  units:
    - name: docker-tcp.socket
      enable: true
      contents: |
        [Unit]
        Description=Docker Socket for the API

        [Socket]
        ListenStream=2375
        Service=docker.service
        BindIPv6Only=both

        [Install]
        WantedBy=sockets.target
    - name: usr-local.mount
      enable: true
      contents: |
        [Mount]
        What=/opt/local
        Where=/usr/local
        Options=bind

        [Install]
        WantedBy=multi-user.target
    - name: install-minikube.service
      enable: true
      contents: |
        [Unit]
        Description=Install minikube
        ConditionPathExists=!/usr/local/bin/localkube

        [Service]
        Type=oneshot
        ExecStart=/opt/minikube/install-minikube.sh
        RemainAfterExit=true
        User=core

        [Install]
        WantedBy=multi-user.target
    - name: install-bricks.service
      enable: true
      contents: |
        [Unit]
        Description=Install bricks

        [Service]
        Type=oneshot
        ExecStart=/opt/bricks/install-bricks.sh
        RemainAfterExit=true
        User=core

        [Install]
        WantedBy=multi-user.target
    - name: export-bricks.service
      enable: true
      contents: |
        [Unit]
        Description=Export bricks

        [Service]
        Type=oneshot
        ExecStart=/opt/bricks/export-bricks.sh
        RemainAfterExit=true
        User=core

        [Install]
        WantedBy=multi-user.target
update:
  group: stable
locksmith:
  reboot_strategy: reboot
  #window_start: "Mon 07:00"
  #window_length: "3h"
storage:
  directories:
    - filesystem: "root"
      path: "/opt"
      mode: 0755
    - filesystem: "root"
      path: "/opt/minikube"
      mode: 0755
    - filesystem: "root"
      path: "/opt/bricks"
      mode: 0755
    - filesystem: "root"
      path: "/opt/local"
      mode: 0755
    - filesystem: "root"
      path: "/opt/local/sbin"
      mode: 0755
    - filesystem: "root"
      path: "/opt/local/lib64"
      mode: 0755
    - filesystem: "root"
      path: "/opt/local/lib"
      mode: 0755
    - filesystem: "root"
      path: "/opt/local/bin"
      mode: 0755
  files:
    - filesystem: "root"
      path: "/opt/bricks/install-bricks.sh"
      mode: 0755
      contents:
        inline: |
          #!/bin/bash -e

          # Wait for NFS mounts
          for i in {1..150}; do # timeout for 5 minutes
            if [ -n "$(/bin/ls -d /Users/* 2>/dev/null)" ]; then
              break
            fi
            echo "Waiting for NFS mounts..."
            sleep 2
          done

          DOCKER_VERSION=$(docker version -f {{.Client.Version}})
          echo "Docker client version to install ${DOCKER_VERSION}"

          USER_HOME=$(echo /Users/* | head -1)
          DOCKER=${HOME}/.docker
          mkdir -p $DOCKER

          URL=https://download.docker.com/mac/static/edge/$(uname -m)/docker-${DOCKER_VERSION}.tgz

          echo "Fetching docker image from $URL"
          curl -s -o - $URL | tar xzf - -O docker/docker > ${DOCKER}/docker

          sudo chmod +x ${DOCKER}/docker

          mkdir -p ${USER_HOME}/.bricks/bin
          cp -af ${DOCKER}/docker ${USER_HOME}/.bricks/bin/docker
          rm -rf $DOCKER
    - filesystem: "root"
      path: "/opt/bricks/export-bricks.sh"
      mode: 0755
      contents:
        inline: |
          #!/bin/bash -e

          # Wait for NFS mounts
          for i in {1..150}; do # timeout for 5 minutes
            if [ -n "$(/bin/ls -d /Users/* 2>/dev/null)" ]; then
              break
            fi
            echo "Waiting for NFS mounts..."
            sleep 2
          done
          USER_HOME=$(echo /Users/* | head -1)
          EXPORT_SCRIPT=${HOME}/.export
          USER_EXPORT_SCRIPT=${USER_HOME}/.bricks/export
          rm ${USER_EXPORT_SCRIPT} &> /dev/null

          echo "[INFO] Creating ${EXPORT_SCRIPT} dir"
          mkdir -p ${EXPORT_SCRIPT}

          echo "[INFO] Generating export script"

          (
          cat <<'EOF'
          clear_bricks() {
            export PATH=$(echo $PATH | sed "s!$HOME/.bricks/bin:!!g")
            if [[ -n "$OLD_DOCKER_TLS_VERIFY" ]]; then
              export DOCKER_TLS_VERIFY="$OLD_DOCKER_TLS_VERIFY"
            fi
            unset DOCKER_CONFIG
            unset DOCKER_HOST
            if [[ -n "$OLD_KUBECONFIG" ]]; then
              export KUBECONFIG="$OLD_KUBECONFIG"
            else
              unset KUBECONFIG
            fi
          }

          set_bricks_1() {
            clear_bricks

            export DOCKER_HOME=tcp://192.168.42.10:2376
            export OLD_DOCKER_TLS_VERIFY=$DOCKER_TLS_VERIFY
            unset DOCKER_TLS_VERIFY
          }

          set_bricks_2() {
            clear_bricks

            export PATH=$HOME/.bricks/bin:$(echo $PATH | sed "s!$HOME/.bricks/bin:!!g")
            export DOCKER_CONFIG="$HOME/.bricks/docker"
            export DOCKER_HOST="tcp://k8s.vagrant.amobee.com:2375"
            export KUBECONFIG=$HOME/.bricks/clusters/vagrant/kubeconfig:$HOME/.kube/config
            export OLD_DOCKER_TLS_VERIFY=$DOCKER_TLS_VERIFY
            unset DOCKER_TLS_VERIFY
          }

          set_bricks_2
          EOF
          ) > ${EXPORT_SCRIPT}/export

          FILE_CONTENTS=$(cat ${EXPORT_SCRIPT}/export)
          echo "[INFO] export script contents ${FILE_CONTENTS}"

          echo "[INFO] Coping export file to ${USER_EXPORT_SCRIPT}"
          cp -af ${EXPORT_SCRIPT}/export ${USER_EXPORT_SCRIPT}
          echo "[INFO] Done copying"

          rm -rf ${EXPORT_SCRIPT} &> /dev/null

          if [[ -f "${USER_HOME}/.bash_profile" ]]; then
            echo "[INFO] ${USER_HOME}/.bash_profile found, updating"
            CURRENT_BASH_PROFILE=$(cat ${USER_HOME}/.bash_profile)
            if [[ ${CURRENT_BASH_PROFILE} == *"Add ~/.bricks/export"* ]]; then
              echo "[INFO] ${USER_HOME}/.bash_profile already contains update, skipping"
              exit 0
            fi
            echo "[INFO] backing up existing .bash_profile as .bash_profile-bricks2.bak"
            cp -af ${USER_HOME}/.bash_profile ${USER_HOME}/.bash_profile-bricks2.bak
            echo "" >> ${USER_HOME}/.bash_profile
            echo "# Add ~/.bricks/export" >> ${USER_HOME}/.bash_profile
            echo "source ${USER_EXPORT_SCRIPT}" >> ${USER_HOME}/.bash_profile
            echo "[INFO] Updated ${USER_HOME}/.bash_profile"
          else
            echo "[INFO] ${USER_HOME}/.bash_profile not found, creating"
            echo "source ${USER_HOME}/.profile" > ${USER_HOME}/.bash_profile
            echo "# Add ~/.bricks/export" > ${USER_HOME}/.bash_profile
            echo "source ${USER_EXPORT_SCRIPT}" >> ${USER_HOME}/.bash_profile
            echo "[INFO] Created ${USER_HOME}/.bash_profile"
          fi
    - filesystem: "root"
      path: "/opt/minikube/install-minikube.sh"
      mode: 0755
      contents:
        inline: |
          #!/bin/bash -e

          # Wait for NFS mounts
          for i in {1..150}; do # timeout for 5 minutes
            if [ -n "$(/bin/ls -d /Users/* 2>/dev/null)" ]; then
              break
            fi
            echo "Waiting for NFS mounts..."
            sleep 2
          done

          export MK=/usr/local/bin/minikube
          export KUBECTL=/usr/local/bin/kubectl
          USER_HOME=$(echo /Users/* | head -1)
          VAGRANT=${USER_HOME}/.bricks/clusters/vagrant

          sudo curl -Lo $MK https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && sudo chmod +x $MK
          sudo curl -Lo $KUBECTL https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && sudo chmod +x $KUBECTL

          export MINIKUBE_WANTUPDATENOTIFICATION=true
          export MINIKUBE_WANTREPORTERRORPROMPT=false
          export MINIKUBE_WANTKUBECTLDOWNLOADMSG=false
          export MINIKUBE_HOME=$USER_HOME/.bricks/clusters/vagrant
          export CHANGE_MINIKUBE_NONE_USER=true

          export KUBECONFIG=$HOME/vagrant/kubeconfig

          rm -rf $HOME/vagrant
          mkdir -p $HOME/vagrant
          mkdir -p $USER_HOME/.bricks/clusters
          rm -rf $USER_HOME/.bricks/clusters/vagrant
          ln -s $HOME/vagrant $USER_HOME/.bricks/clusters/vagrant

          sudo -E $MK start --vm-driver=none --loglevel 0 --logtostderr

          set -x

          rm -rf $VAGRANT
          cp -af $HOME/vagrant $VAGRANT
          rm -rf $HOME/vagrant
          mkdir -p $HOME/.kube
          ln -s $USER_HOME/.bricks/clusters/vagrant/kubeconfig $HOME/.kube/config
          ln -s $USER_HOME/.bricks/clusters/vagrant/.minikube $HOME/.minikube
          unset KUBECONFIG

          # this for loop waits until kubectl can access the api server that Minikube has created
          for i in {1..150}; do # timeout for 5 minutes
             $KUBECTL get po &> /dev/null || true
             if [ $? -ne 1 ]; then
                break
            fi
            sleep 2
          done

# vim:ft=yaml
